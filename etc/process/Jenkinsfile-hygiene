//
// This Jenkinsfile defines the "Multibranch Pipeline" that runs the "hygiene tests" for each push into this
// repository or a clone thereof, provided that the clone is made by one of the known contributors.
//
// Note that this file is in the so called "Declarative Pipeline" syntax
//
// See https://jenkins.io/doc/book/pipeline/jenkinsfile/
//
// WARNING: Keep in sync as much as possible with the Jenkinsfile in the same directory!
//
// TODO: Should be part of the main Jenkinsfile, doing the hygiene tests on the output of the publish process,
//       especially the artifacts of the ontology-product.
//
pipeline {

  agent none

  environment {
    FIBO_INFRA_BRANCH = 'master'
    LC_ALL = 'en_US.UTF-8'
    LANG = 'en_US.UTF-8'
    LANGUAGE = 'en_US.UTF-8'
  }

  options {

    buildDiscarder(
      logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '5')
    )
    //
    // We let each stage running on each jenkins slave / agent decide what to check out or not
    //
    skipDefaultCheckout()
    //
    // Skip stages once the build status has gone to UNSTABLE.
    //
    skipStagesAfterUnstable()
    //
    // There must be SOME limit, if it hangs or whatever then that's a bug and therefore cancel the job.
    //
    timeout(time: 23, unit: 'HOURS')
    //
    // Prepend all console output generated by the Pipeline run with the time at which the line was emitted
    //
    //timestamps()
  }

  stages {

    stage('Prepare') {
      agent {
        label 'stardog'
      }
      environment {
        LC_ALL = 'en_US.UTF-8'
        LANG = 'en_US.UTF-8'
        LANGUAGE = 'en_US.UTF-8'
      }

      steps {
        echo "Cleaning workspace:"
        sh 'rm -rf ${WORKSPACE}/* || true'
        echo "Done cleaning"

        //
        // Copy the rdf-toolkit.jar file artifact from the rdf-toolkit-build job (pre-requisite for running publish script)
        //
        step([$class: 'CopyArtifact', filter: '**/rdf-toolkit.jar', fingerprintArtifacts: true, flatten: true, projectName: 'rdf-toolkit-build'])
        //
        // Copy the pellet jar from the build-pellet job
        //
        step([$class: 'CopyArtifact', filter: '**/pellet-cli-*.jar', fingerprintArtifacts: true, flatten: true, projectName: 'build-pellet', target: 'pellet'])
        //
        // Check out the fibo repo' content into the ./fibo directory
        //
        dir('fibo') {
          checkout scm
          echo 'Checked out fibo repo'
        }
        //
        // Then check out the fibo-infra repo content into the ./fibo-infra directory
        //
        dir('fibo-infra') {
          //
          // If you want to check out a specific version of fibo-infra add the "branch:" parameter
          //
          git branch: env.FIBO_INFRA_BRANCH, credentialsId: 'edmcjenkins_at_edmcouncil.org', url: 'git@github.com:edmcouncil/fibo-infra.git'
          //
          // git credentialsId: 'edmcjenkins_at_edmcouncil.org', url: 'git@github.com:edmcouncil/fibo-infra.git'
          echo "Checked out fibo-infra repo, branch ${env.FIBO_INFRA_BRANCH}"
          //
          // Stash all the tools in the bin directory
          //
          //stash includes: 'bin/**', name: 'infra-bin'
          //
          // Stash all the jenkins related stuff in the jenkins directory
          //
          //stash includes: 'jenkins/**', name: 'infra-jenkins'
        }
        //
        // Then run the init command on the fibo-publish script which will set all the GIT_* and JIRA_* vars
        // correctly and store their values in some .env files.
        //
        dir('fibo-infra') {
          echo 'Execute the publish-fibo.sh script (just to initialize the environment variables):'
          sh './jenkins/bin/publish-fibo.sh init'
          echo 'Finished executing the publish-fibo script (init section)'
        }
        initEnvironment()
        //
        // Now stash all files in the env directory for reuse in other workspaces on other agents/slaves
        //
        stash includes: 'env/**', name: 'environment'
        //
        // Then check out the LCC repo into the ./LCC directory
        //
        dir('LCC') {
          git url: 'https://github.com/edmcouncil/LCC.git', credentialsId: 'edmcjenkins'
          echo 'Checked out the LCC repo'
        }
        //
        // Install jena in the ./jena directory, gettting rid of the version number in the directory name so that
        // we can refer to it further down this file without having to explicitly mention the version number.
        //
        echo 'Checked it all out'
        sh 'curl --location -O --url http://www-us.apache.org/dist/jena/binaries/apache-jena-3.8.0.tar.gz'
        sh 'tar xvzf apache-jena-3.8.0.tar.gz'
        sh 'rm apache-jena-3.8.0.tar.gz'
        sh 'mv apache-jena-3.8.0 jena'
        //
        // Install SPIN
        //
        dir('spin') {
          sh 'curl --location --output spin.jar --url https://www.topquadrant.com/repository/spin/org/topbraid/spin/2.0.0/spin-2.0.0.jar'
        }
      }
    } // end of stage 'Prepare'

//    stage('Build Product Ontology') {
//      agent {
//        label 'stardog'
//      }
//
//      steps {
//        //
//        // Execute the publish script
//        //
//        sh "./fibo-infra/jenkins/bin/publish-fibo.sh ontology"
//        //
//        // Now stash all files in the env directory for reuse in the other worker nodes
//        // used by the next products
//        //
//        stash includes: '**', name: 'ontology-data'
//      }
//    } // end of stage 'Build Product Ontology'

    stage('Hygiene Tests') {
      agent {
        label 'stardog'
      }
      environment {
        //
        // JG> The link to jena below is very version specific, there's also
        //    a symlink /usr/local/jena which will always point to the latest
        //     installed version.
        //
        JENA_HOME = "${env.WORKSPACE}/jena"
      }
      steps {
        //echo "JENA_HOME=${JENA_HOME}"
        //sh 'ls $JENA_HOME'
        //sh 'ls $JENA_HOME/lib'
        sh '''
          #for lib in `ls $JENA_HOME/lib/*.jar`; do
          #  JENA_LIBS=$JENA_LIBS:$lib
          #done
          #export CLASSPATH=$CLASSPATH:/usr/local/SPIN-from-RIF/:$JENA_LIBS:/usr/local/SPIN-from-RIF/SPIN/spin-1.3.3.jar
          export CLASSPATH=$CLASSPATH:${WORKSPACE}/spin:${WORKSPACE}/jena/lib
          mkdir target >/dev/null 2>&1 || true
          echo "Calling arq"
          #
          # Get ontologies for Dev
          #
          ./jena/bin/arq $(find ./fibo -name "*.rdf" | grep -v "/etc/" | sed "s/^/--data=/") \
            --query=./fibo/etc/testing/echo.sq \
            --results=TTL > ./target/DEV.ttl

          #
          # Get ontologies for Prod
          #
          ./jena/bin/arq \
            $(grep -r 'utl-av[:;.]Release' ./fibo | sed 's/:.*$//;s/^/--data=/' | grep -F ".rdf") \
            --query=./fibo/etc/testing/echo.sq \
            --results=TTL > ./target/PROD.ttl

          echo "Running tests"
          echo "Errors in DEV"
          echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
          find ./fibo/etc \
            -name 'testHygiene*.sq' \
            -exec grep "banner" {} \\; \
            -exec ./jena/bin/arq --data=./target/DEV.ttl --query={} \\; | sed 's/PRODERROR/WARN/'
          echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
          echo "Errors in PROD"
          echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
          find ./fibo/etc \
            -name 'testHygiene*.sq' \
            -exec grep "banner" {} \\; \
            -exec ./jena/bin/arq --data=./target/PROD.ttl --query={} \\; | sed 's/PRODERROR/ERROR/'
          echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
        '''
        archiveArtifacts artifacts: 'target/*.ttl', fingerprint: true
      }
    }

  } // end of stages
} // end of pipeline

def initEnvironment() {

  //
  // Read the GIT and JIRA environment variables from files in the ./env directory
  // that have been created by the publish-fibo.sh script so that we can reuse that
  // logic elsewhere in the Jenkinsfile pipeline.
  //
  env.GIT_BRANCH    = readFile './env/GIT_BRANCH'.trim()
  env.GIT_TAG_NAME  = readFile './env/GIT_TAG_NAME'.trim()
  env.GIT_AUTHOR    = readFile './env/GIT_AUTHOR'.trim()
  env.GIT_COMMENT   = readFile './env/GIT_COMMENT'.trim()
  env.GIT_COMMIT    = readFile './env/GIT_COMMIT'.trim()
  env.JIRA_ISSUE    = readFile './env/JIRA_ISSUE'.trim()

  echo "GIT_BRANCH=${env.GIT_BRANCH}"
  echo "GIT_TAG_NAME=${env.GIT_TAG_NAME}"
  echo "GIT_AUTHOR=${env.GIT_AUTHOR}"
  echo "GIT_COMMENT=${env.GIT_COMMENT}"
  echo "GIT_COMMIT=${env.GIT_COMMIT}"
  echo "JIRA_ISSUE=${env.JIRA_ISSUE}"
}
